plot_annotation(
title = "Envelope of System Variables Across Government Incentive Scenarios",
subtitle = "Shaded area = min-max range across gov incentives [0–1]; Red line = gov_incent = 0.5 scenario",
theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 15)))
)
ggplot(df_env, aes(x = year)) +
geom_ribbon(aes(ymin = min_value, ymax = max_value), fill = "#4C72B0", alpha = 0.25) +       # Softer blue
geom_line(aes(y = min_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(aes(y = max_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(data = df_ref, aes(x = year, y = value), color = "#DD1C77", size = 0.4) +            # Strong pink/red for reference line
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2), expand = expansion(mult = c(0, 0))) +
scale_x_continuous(breaks = seq(0, sim_years, 5)) +
labs(
title = gsub("\\.", " ", tools::toTitleCase(varname)),   # Clean up title
x = "Year",
y = "Value (standardized)"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5, margin = margin(b = 10)),
axis.title = element_text(face = "bold", size = 5),
axis.text = element_text(size = 10),
panel.grid.major = element_line(color = "grey80", size = 0.3),
panel.grid.minor = element_blank(),
legend.position = "none",
plot.margin = margin(10, 10, 10, 10)
)
plot_list <- lapply(unique(envelope_data$variable), function(varname) {
df_env <- envelope_data %>% filter(variable == varname)
df_ref <- reference_data %>% filter(variable == varname)
ggplot(df_env, aes(x = year)) +
geom_ribbon(aes(ymin = min_value, ymax = max_value), fill = "#4C72B0", alpha = 0.25) +       # Softer blue
geom_line(aes(y = min_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(aes(y = max_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(data = df_ref, aes(x = year, y = value), color = "#DD1C77", size = 0.4) +            # Strong pink/red for reference line
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2), expand = expansion(mult = c(0, 0))) +
scale_x_continuous(breaks = seq(0, sim_years, 5)) +
labs(
title = gsub("\\.", " ", tools::toTitleCase(varname)),   # Clean up title
x = "Year",
y = "Value (standardized)"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5, margin = margin(b = 10)),
axis.title = element_text(face = "bold", size = 5),
axis.text = element_text(size = 10),
panel.grid.major = element_line(color = "grey80", size = 0.3),
panel.grid.minor = element_blank(),
legend.position = "none",
plot.margin = margin(10, 10, 10, 10)
)
})
wrap_plots(plotlist = plot_list, ncol = 2) +
plot_annotation(
title = "Envelope of System Variables Across Government Incentive Scenarios",
subtitle = "Shaded area = min-max range across gov incentives [0–1]; Red line = gov_incent = 0.5 scenario",
theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 15)))
)
plot_list <- lapply(unique(envelope_data$variable), function(varname) {
df_env <- envelope_data %>% filter(variable == varname)
df_ref <- reference_data %>% filter(variable == varname)
ggplot(df_env, aes(x = year)) +
geom_ribbon(aes(ymin = min_value, ymax = max_value), fill = "#4C72B0", alpha = 0.25) +       # Softer blue
geom_line(aes(y = min_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(aes(y = max_value), color = "#4C72B0", linetype = "dashed", size = 0.6) +
geom_line(data = df_ref, aes(x = year, y = value), color = "#DD1C77", size = 0.4) +            # Strong pink/red for reference line
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2), expand = expansion(mult = c(0, 0))) +
scale_x_continuous(breaks = seq(0, sim_years, 5)) +
labs(
title = gsub("\\.", " ", tools::toTitleCase(varname)),   # Clean up title
x = "Year",
y = "Value (standardized)"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 10, hjust = 0.5, margin = margin(b = 10)),
axis.title = element_text(face = "bold", size = 10),
axis.text = element_text(size = 10),
panel.grid.major = element_line(color = "grey80", size = 0.3),
panel.grid.minor = element_blank(),
legend.position = "none",
plot.margin = margin(10, 10, 10, 10)
)
})
wrap_plots(plotlist = plot_list, ncol = 2) +
plot_annotation(
title = "Envelope of System Variables Across Government Incentive Scenarios",
subtitle = "Shaded area = min-max range across gov incentives [0–1]; Red line = gov_incent = 0.5 scenario",
theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 15)))
)
setwd("~/Google Drive/My Drive/UvA/Independent Papers")
setwd("~/Google Drive/My Drive/UvA/Independent Papers/localvar")
usethis::create_package(".")
library(devtool)
library(devtools)
install.packages("devtools")
usethis::create_package(".")
devtools::load_all()
install.packages("simstudy")
getwd
getwd()
library(simstudy)
# Define x and y
def <- defData(varname = "x", dist = "normal", formula = 0, variance = 1)
def <- defData(def, varname = "y", dist = "normal",
formula = "2 + 1.5 * x", variance = 0.5)
# Generate data
data <- genData(100, def)
# Preview
head(data)
View(def)
mod <- run_volatility_pipeline(x = data$x, x_type = "continuous",
y = data$y, y_type = "continuous")
str(mod)
summary(mod)
names(mod)
str(mod)
View(mod)
# 1. Extract IQR scores from every window
iqr_vec  <- vapply(mod$windows,
function(w) w$score$iqr,
numeric(1))
# 2. Extract the x-stat means from every window
mean_vec <- vapply(mod$windows,
function(w) w$x_stats$mean,
numeric(1))
# 3. Bind column-wise and give clear names
win_stats <- data.frame(mean = mean_vec,
iqr  = iqr_vec)
# Peek at the result
head(win_stats)
usethis::use_build_ignore("script")
colmeans <- colMeans(win_stats)
colmeans
View(mod)
win_stats
simulate_xy <- function(n      = 250,
err    = c("normal", "lognormal", "exponential",
"t", "beta"),
df     = 3,
beta_a = 2, beta_b = 5,
seed   = NULL) {
if (!is.null(seed)) set.seed(seed)
err <- match.arg(err)
library(simstudy)   # data definitions
library(data.table) # simstudy returns data.table objects
## 1. Define baseline x  ~  N(0, 1)
def <- defData(varname = "x", dist = "normal", formula = 0, variance = 1)
## 2. Generate the baseline data set
dt  <- genData(n, def)      # gives columns id + x
## 3. Draw error vector ε according to requested distribution
ε <- switch(err,
normal      = rnorm(n, 0, 1),
lognormal   = {           # subtract mean to center at 0
z <- rlnorm(n, 0, 1)
z - exp(0.5)            # E[logN(0,1)] = exp(0.5)
},
exponential = {           # right-skew, mean 1; shift to mean 0
z <- rexp(n, 1)
z - 1
},
t = rt(n, df),            # heavy-tail, symmetric
beta = {                  # bounded, skewed; scale & centre
z <- rbeta(n, beta_a, beta_b)
z_centered <- z - beta_a / (beta_a + beta_b)
# rescale to unit SD (optional, helps compare dists)
z_centered / sqrt(
(beta_a * beta_b) /
((beta_a + beta_b)^2 * (beta_a + beta_b + 1))
)
}
)
## 4. Add ε and compute y
dt[, error := ε]
dt[,  y   := x + error]
dt[]
}
generate_datasets_list <- function(n = 250,
err = "normal",
reps = 2000,
seed = 123) {
set.seed(seed)
datasets <- vector("list", reps)
for (i in seq_len(reps)) {
datasets[[i]] <- simulate_xy(n = n, err = err)
}
return(datasets)
}
sim_data_er_normal <- generate_datasets_list(err = "normal")
devtools::load_all()
sim_data_er_normal <- generate_datasets_list(err = "normal")
sim_data_er_normal <- generate_datasets_list(err = "normal")
sim_data_er_normal <- generate_datasets_list(err = "normal")
library(data.table)
sim_data_er_normal <- generate_datasets_list(err = "normal")
devtools::load_all()
library(data.table)
sim_data_er_normal <- generate_datasets_list(err = "normal")
devtools::load_all()
sim_data_er_normal <- generate_datasets_list(err = "normal")
library(data.table)
sim_data_er_normal <- generate_datasets_list(err = "normal")
simulate_xy <- function(n = 250,
err = c("normal", "lognormal", "exponential", "t", "beta"),
df = 3,
beta_a = 2, beta_b = 5,
seed = NULL) {
if (!is.null(seed)) set.seed(seed)
err <- match.arg(err)
# Define baseline: x ~ N(0, 1)
def <- simstudy::defData(varname = "x", dist = "normal", formula = 0, variance = 1)
dt  <- simstudy::genData(n, def)
dt  <- as.data.frame(dt)  # drop "CEDTA" class safely
# Generate error
ε <- switch(err,
normal      = rnorm(n),
lognormal   = rlnorm(n, 0, 1) - exp(0.5),
exponential = rexp(n) - 1,
t           = rt(n, df),
beta        = {
z <- rbeta(n, beta_a, beta_b)
z_centered <- z - beta_a / (beta_a + beta_b)
z_centered / sqrt((beta_a * beta_b) / ((beta_a + beta_b)^2 * (beta_a + beta_b + 1)))
}
)
# Add error and response variable
dt$error <- ε
dt$y     <- dt$x + ε
return(dt)
}
generate_datasets_list <- function(n = 250,
err = "normal",
reps = 2000,
seed = 123) {
set.seed(seed)
datasets <- vector("list", reps)
for (i in seq_len(reps)) {
datasets[[i]] <- simulate_xy(n = n, err = err)
}
return(datasets)
}
sim_data_er_normal <- generate_datasets_list(err = "normal")
sim_data_er_normal <- generate_datasets_list(err = "normal")
sim_res_er_normal <- run_volatility_pipeline(x = sim_data_er_normal$x, x_type = "continuous",
y = sim_data_er_normal$y, y_type = "continuous")
sim_res_er_normal <- lapply(
sim_data_er_normal,
function(d)
run_volatility_pipeline(
x      = d$x,
x_type = "continuous",
y      = d$y,
y_type = "continuous"
)
)
View(sim_data_er_normal)
View(sim_res_er_normal)
sim_res_er_normal[[1]][["windows"]][[1]][["x_stats"]][["mean"]]
sim_res_er_normal[[1]][["windows"]][[1]][["score"]][["iqr"]]
extract_sim_volatility_summary <- function(results_list) {
library(abind)  # for combining arrays row-wise
get_row <- function(res) {
w <- res[["windows"]][[1]]
x_means <- w[["x_stats"]][["mean"]]
iqr_scores <- w[["score"]][["iqr"]]
# Combine: mean_1, mean_2, ..., iqr_1, iqr_2, ...
c(x_means, iqr_scores)
}
# Apply to all runs
mat <- t(vapply(results_list, get_row, numeric(length(results_list[[1]][["windows"]][[1]][["x_stats"]][["mean"]]) * 2)))
# Name columns clearly
n_folds <- length(results_list[[1]][["windows"]][[1]][["x_stats"]][["mean"]])
colnames(mat) <- c(
paste0("mean_", seq_len(n_folds)),
paste0("iqr_", seq_len(n_folds))
)
return(as.data.frame(mat))
}
install.packages("abind")
summary_df <- extract_volatility_summary(sim_res_er_normal)
devtools::load_all()
summary_df <- extract_sim_volatility_summary(sim_res_er_normal)
View(summary_df)
View(summary_df)
head(summary_df)
extract_vol_mats <- function(results_list) {
n_runs    <- length(results_list)
n_windows <- length(results_list[[1]][["windows"]])
# pre-allocate
iqr_mat  <- matrix(NA_real_, nrow = n_runs, ncol = n_windows)
mean_mat <- matrix(NA_real_, nrow = n_runs, ncol = n_windows)
for (run in seq_len(n_runs)) {
for (win in seq_len(n_windows)) {
w <- results_list[[run]][["windows"]][[win]]
mean_mat[run, win] <- w[["x_stats"]][["mean"]]
iqr_mat[run,  win] <- w[["score"]][["iqr"]]
}
}
colnames(iqr_mat)  <- paste0("iqr_w",  seq_len(n_windows))
colnames(mean_mat) <- paste0("mean_w", seq_len(n_windows))
rownames(iqr_mat)  <- rownames(mean_mat) <- paste0("run_", seq_len(n_runs))
list(
iqr_mat  = iqr_mat,                     # runs × windows
mean_mat = mean_mat,                    # runs × windows
all_mat  = cbind(iqr_mat, mean_mat)     # runs × (2 × windows)
)
}
return(list(
means = means,  # [fold, run, window]
iqrs  = iqrs
))
extract_vol_mats <- function(results_list) {
n_runs    <- length(results_list)
n_windows <- length(results_list[[1]][["windows"]])
# pre-allocate
iqr_mat  <- matrix(NA_real_, nrow = n_runs, ncol = n_windows)
mean_mat <- matrix(NA_real_, nrow = n_runs, ncol = n_windows)
for (run in seq_len(n_runs)) {
for (win in seq_len(n_windows)) {
w <- results_list[[run]][["windows"]][[win]]
mean_mat[run, win] <- w[["x_stats"]][["mean"]]
iqr_mat[run,  win] <- w[["score"]][["iqr"]]
}
}
colnames(iqr_mat)  <- paste0("iqr_w",  seq_len(n_windows))
colnames(mean_mat) <- paste0("mean_w", seq_len(n_windows))
rownames(iqr_mat)  <- rownames(mean_mat) <- paste0("run_", seq_len(n_runs))
list(
iqr_mat  = iqr_mat,                     # runs × windows
mean_mat = mean_mat,                    # runs × windows
all_mat  = cbind(iqr_mat, mean_mat)     # runs × (2 × windows)
)
}
summary_df <- extract_vol_mats(sim_res_er_normal)
head(extract_vol_mats)
View(summary_df)
summary_df[["all_mat"]]
View(summary_df)
dim(vol_mats$all_mat)
dim(summary_df$all_mat)
zscale_per_run <- function(mat) {
t(apply(mat, 1, function(row) {
mu <- mean(row)
sd_ <- sd(row)
if (sd_ == 0) rep(0, length(row)) else (row - mu) / sd_
}))
}
z_mean_mat <- zscale_per_run(vol_mats$mean_mat)
vol_mats <- extract_vol_mats(sim_res_er_normal)
z_mean_mat <- zscale_per_run(vol_mats$mean_mat)
colnames(z_mean_mat) <- colnames(vol_mats$mean_mat)
rownames(z_mean_mat) <- rownames(vol_mats$mean_mat)
vol_array_z <- array(NA_real_, dim = c(nrow(z_mean_mat), ncol(z_mean_mat), 3),
dimnames = list(
run    = rownames(z_mean_mat),
window = colnames(z_mean_mat),
stat   = c("iqr", "mean", "mean_z")
))
vol_array_z[, , 1] <- vol_mats$iqr_mat
vol_array_z[, , 1] <- vol_mats$iqr_mat
vol_array_z[, , 2] <- vol_mats$mean_mat
vol_array_z[, , 3] <- z_mean_mat
vol_array_z[, , 1] <- vol_mats$iqr_mat
vol_array_z[, , 2] <- vol_mats$mean_mat
vol_array_z[, , 3] <- z_mean_mat
# Build a 2D vector for each run’s change over windows
# E.g., movement in (mean_z, iqr_z)
x <- vol_array[, , "mean_z"]
x <- vol_array_z[, , "mean_z"]
y <- vol_array_z[, , "iqr"]
y <- vol_array_z[, , "iqr"]
x <- vol_array_z[, , "mean_z"]
arrows(x0 = x[, -ncol(x)], y0 = y[, -ncol(y)],
x1 = x[, -1],        y1 = y[, -1],
length = 0.05, col = rgb(0,0,1,0.2))
assign_window_logic <- function(x_type, y_type, x_k = NULL, y_k = NULL) {
x_type <- match.arg(x_type, c("continuous", "discrete"))
y_type <- match.arg(y_type, c("continuous", "discrete"))
if (x_type == "continuous") {
if (y_type == "continuous") return(list(sort = "x"))
stop("Estimation on discrete y is not supported for continuous–discrete combinations.")
}
# x_type == "discrete"
if (y_type == "continuous") return(list(sort = c("x", "y")))
# y_type == "discrete"
if (is.null(x_k) || is.null(y_k)) {
stop("Cardinalities x_k and y_k must be provided for discrete–discrete data.")
}
if (x_k <= 2 && y_k <= 2) {
stop("Binary–binary data is not supported for window-based estimation.")
}
if (x_k > y_k) {
stop("Estimation on lower-cardinality discrete axis is not supported (x_k > y_k).")
}
return(list(sort = c("x", "y")))
}
#' Create sliding windows on paired x/y data
#'
#' @param x Numeric vector of x values
#' @param y Numeric vector of y values
#' @param window_size Size of each window (default: 30)
#' @param step_size Step size for sliding window (default: 1)
#' @param sort Whether to sort x before windowing (default: TRUE)
#' @return A 'windowed_data' object
#' @export
# ==== 1. Data preparation ====================================================
make_windows <- function(
x, y,
window_size = 30,
step_size   = 1,
sort        = TRUE          # NEW: can also be "x" or c("x","y")
) {
stopifnot(length(x) == length(y))
stopifnot(step_size >= 1, window_size >= 1)
## ------------------------------------------------------------------------
## 1.  Determine ordering --------------------------------------------------
## ------------------------------------------------------------------------
index_vec <- seq_along(x)
# Helper to recognise the c("x","y") case even if attributes differ
is_xy_sort <- function(s) {
is.character(s) && length(s) == 2 &&
identical(unname(s), c("x", "y"))
}
if (isFALSE(sort)) {
ord <- index_vec                                       # keep original order
} else if (isTRUE(sort)) {                               # legacy heuristic
if (length(unique(x)) <= 2) {
ord <- order(y)                                      # binary x → sort on y
} else {
ord <- order(x)                                      # otherwise sort on x
}
} else if (identical(sort, "x")) {
ord <- order(x)                                        # explicit x-only sort
} else if (is_xy_sort(sort)) {
ord <- order(x, y)                                     # x primary, y within x
} else {
stop(
"'sort' must be TRUE, FALSE, \"x\", or c(\"x\", \"y\").\n",
"Received: ", deparse(sort)
)
}
# Re-order vectors (no-op if ord is the identity)
x <- x[ord]; y <- y[ord]; index_vec <- index_vec[ord]
## ------------------------------------------------------------------------
## 2.  Window construction -------------------------------------------------
## ------------------------------------------------------------------------
n       <- length(y)
windows <- vector("list", 0L)
fold_id <- 1
# Helper factory for each window record ----------------------------
build_win <- function(slice_idx) {
list(
id = list(
fold_id   = fold_id,
start_idx = min(slice_idx),
end_idx   = max(slice_idx),
range_x   = range(x[slice_idx]),
idx       = index_vec[slice_idx]
),
x_stats = list(
mean = mean(x[slice_idx]),
sd   = stats::sd(x[slice_idx])
),
y_stats = list(
mean = mean(y[slice_idx]),
sd   = stats::sd(y[slice_idx])
),
x_win = x[slice_idx],
y_win = y[slice_idx]
)
}
# 2a Growing windows (2 … window_size-1) ----------------------------
for (w in 2:(window_size - 1)) {
windows[[fold_id]] <- build_win(1:w)
fold_id <- fold_id + 1
}
# 2b Full-size sliding windows --------------------------------------
for (start in seq(1, n - window_size + 1, by = step_size)) {
windows[[fold_id]] <- build_win(start:(start + window_size - 1))
fold_id <- fold_id + 1
}
# 2c Shrinking windows (window_size-1 … 2) --------------------------
for (w in rev(2:(window_size - 1))) {
windows[[fold_id]] <- build_win((n - w + 1):n)
fold_id <- fold_id + 1
}
## ------------------------------------------------------------------------
## 3.  Return - windowed_data object --------------------------------------
## ------------------------------------------------------------------------
structure(
list(
data    = list(x = x, y = y, idx = index_vec),
windows = windows,
meta    = list(
history = list(make_windows = list(timestamp = Sys.time())),
window_size = window_size,
step_size   = step_size,
sort        = sort,
n_windows   = length(windows),
n_data      = n
)
),
class = "windowed_data"
)
}
devtools::load_all()
?localvar
??localvar
